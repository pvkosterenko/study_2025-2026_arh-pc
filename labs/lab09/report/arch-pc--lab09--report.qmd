---
## Author
author:
  name: Костеренко Полина
  studID: 1032255196
  group: НПИбд-01-25
  email: kosterenkopolina07@mail.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      city: Москва
      address: ул. Миклухо-Маклая, д. 5к2

## Title
title: "Отчет по лабораторной работе №8"

---

# Цель работы

Познакомиться с методами отладки при помощи GDB, его возможностями.

# Выполнение лабораторной работы

## Реализация подпрограмм в NASM

Создаем каталог для программ ЛБ9, и в нем создаем файл (рис. @fig-a).

![Создаем каталог с помощью команды mkdir и файл с помощью команды touch](./image/1.png){#fig-a width=70%}

Открываем файл в Midnight Commander и заполняем его в соответствии с листингом 9.1 (рис. @fig-b).

![Заполняем файл](./image/2.png){#fig-b width=70%}

Создаем исполняемый файл и запускаем его (рис. @fig-c).

![Запускаем файл и проверяем его работу](./image/3.png){#fig-c width=70%}

Снова открываем файл для редактирования и изменяем его, добавив подпрограмму в подпрограмму(по условию) (рис. @fig-d).

![Изменяем файл, добавляя еще одну подпрограмму](./image/4.png){#fig-d width=70%}

Создаем исполняемый файл и запускаем его (рис. @fig-e).

![Запускаем файл и смотрим на его работу](./image/5.png){#fig-e width=70%}

## Отладка программам с помощью GDB

Создаем новый файл в каталоге(рис. @fig-f).

![Создаем файл](./image/6.png){#fig-f width=70%}

Открываем файл в Midnight Commander и заполняем его в соответствии с листингом 9.2 (рис. @fig-g).

![Заполняем файл](./image/7.png){#fig-g width=70%}

Получаем исходный файл с использованием отладчика gdb (рис. @fig-h).

![Загружаем исходный файл в отладчик](./image/8.png){#fig-h width=70%}

Запускаем команду в отладчике (рис. @fig-i).

![Запускаем программу командой run](./image/9.png){#fig-i width=70%}

Устанавливаем брейкпоинт на метку _start и запускаем программу (рис. @fig-j).

![Запускаем программу с брейкпоином](./image/10.png){#fig-j width=70%}

Смотрим дисассимилированный код программы с помощью команды disassemble, начиная с метки _start(рис. @fig-k).

![Смотрим дисассимилированный код программы](./image/11.png){#fig-k width=70%}

Переключаемся на отображение команд с Intel'овским синтаксисом (рис. @fig-l).

![Переключаемся на синтаксис Intel](./image/12.png){#fig-l width=70%}

Различия отображения синтаксиса машинных команд в режимах ATT и Intel:

1. Порядок операндов: В ATT синтаксисе порядок операндов обратный, сначала указывается исходный операнд, а затем - результирующий операнд. В Intel синтаксисе порядок обычно прямой, результирующий операнд указывается первым, а исходный - вторым.

2. Разделители: В ATT синтаксисе разделители операндов - запятые. В Intel синтаксисе разделители могут быть запятые или косые черты (/).

3. Префиксы размера операндов: В ATT синтаксисе размер операнда указывается перед операндом с использованием префиксов, таких как "b" (byte), "w" (word), "l" (long) и "q" (quadword). В Intel синтаксисе размер операнда указывается после операнда с использованием суффиксов, таких как "b", "w", "d" и "q".

4. Знак операндов: В ATT синтаксисе операнды с позитивными значениями предваряются символом "$". В Intel синтаксисе операнды с позитивными значениями могут быть указаны без символа "$".

5. Обозначение адресов: В ATT синтаксисе адреса указываются в круглых скобках. В Intel синтаксисе адреса указываются без скобок.

6. Обозначение регистров: В ATT синтаксисе обозначение регистра начинается с символа "%". В Intel синтаксисе обозначение регистра может начинаться с символа "R" или "E" (например, "%eax" или "RAX").

Включаем режим псевдографики (рис. @fig-m).

![Включаем отображение регистров, их значений и результат дисассимилирования программы](./image/13.png){#fig-m width=70%}

Проверяем была ли установлена точка останова и устанавливаем точку останова предпоследней инструкции (рис. @fig-n).

![Используем команду info breakpoints и создаем новую точку останова](./image/14.png){#fig-n width=70%}

Посмотрим информацию о всех установленных точках останова (рис. @fig-o).

![Смотрим информацию](./image/15.png){#fig-o width=70%}

Выполняем 5 инструкций командой si  (рис. @fig-p).

![Отслеживаем регистры](./image/16.png){#fig-p width=70%}

Во время выполнения команд менялись регистры: ebx, ecx, edx,eax, eip.

Смотрим значение переменной msg1 по имени (рис. @fig-q).

![Смотрим значение переменной](./image/17.png){#fig-q width=70%}

Смотрим значение переменной msg2 по адресу (рис. @fig-r).

![Смотрим значение переменной](./image/18.png){#fig-r width=70%}

Изменим первый символ переменной msg1 (рис. @fig-s).

![Меняем символ](./image/19.png){#fig-s width=70%}

Изменим первый символ переменной msg2 (рис. @fig-t).

![Меняем символ](./image/20.png){#fig-t width=70%}

Смотрим значение регистра edx в разных форматах (рис. @fig-u).

![Смотрим значение регистра](./image/21.png){#fig-u width=70%}

Изменяем регистор ebx (рис. @fig-v).

![Изменяем регистор командой set](./image/22.png){#fig-v width=70%}

Выводится разные значения, так как команда без кеавычек присваивает регистру вводимое значение.

Прописываем команды для завершения программы и выхода из GDB (рис. @fig-w).

![Прописываем команды c и quit](./image/23.png){#fig-w width=70%}

Копируем файл lab8-2.asm в файл с именем lab09-3.asm (рис. @fig-x).

![Копируем файл](./image/24.png){#fig-x width=70%}

Создаем исполняемый файл и запускаем его в отладчике GDB (рис. @fig-y).

![Создаем и запускаем в отладчике файл](./image/25.png){#fig-y width=70%}

Установим точку останова перед первой инструкцией в программе и запустим ее (рис. @fig-z).

![Устанавливаем точку останова](./image/26.png){#fig-z width=70%}

Смотрим позиции стека по разным адресам (рис. @fig-aa).

![Изучаем полученные данные](./image/27.png){#fig-aa width=70%}

Шаг изменения адреса равен 4 потому что адресные регистры имеют размерность 32 бита(4 байта).

## Задание для самостоятельной работы

### Задание 1

Копируем файл lab8-4.asm(ср №1 в ЛБ8) в файл с именем lab09-3.asm (рис. @fig-ab).

![Копируем файл](./image/28.png){#fig-ab width=70%}

Открываем файл в Midnight Commander и меняем его, создавая подпрограмму (рис. @fig-ac).

![Изменяем файл](./image/29.png){#fig-ac width=70%}

Создаем исполняемый файл и запускаем его (рис. @fig-ad).

![Проверяем работу программы](./image/30.png){#fig-ad width=70%}

### Задание 2

Создаем новый файл в дирректории (рис. @fig-ae).

![Создаем файл](./image/31.png){#fig-ae width=70%}

Открываем файл в Midnight Commander и заполняем его в соответствии с листингом 9.3 (рис. @fig-af).

![Изменяем файл](./image/32.png){#fig-af width=70%}

Создаем исполняемый файл и запускаем его (рис. @fig-ag).

![Создаем и смотрим на работу программы(работает неправильно)](./image/33.png){#fig-ag width=70%}

Создаем исполняемый файл и запускаем его в отладчике GDB и смотрим на изменение решистров командой si (рис. @fig-ah).

![Ищем ошибку регистров в отладчике](./image/34.png){#fig-ah width=70%}

Изменяем программу для корректной работы (рис. @fig-ai).

![Меняем файл](./image/35.png){#fig-ai width=70%}

Создаем исполняемый файл и запускаем его (рис. @fig-aj).

![Создаем и запускаем файл(работает корректно)](./image/36.png){#fig-aj width=70%}

# Выводы

Мы познакомились с методами отладки при помощи GDB и его возможностями.


::: {#refs}
:::
